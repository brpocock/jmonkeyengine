/*
 * Copyright (c) 2003 najgl Project
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1) Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3) Neither the name of 'najgl' nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package jme.geometry.model.ms;

import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileReader;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.IntBuffer;

import jme.geometry.model.*;
import najgl.math.Math;
import najgl.math.Matrix34f;
import najgl.math.Vector3f;
import najgl.math.Vector4f;
import najgl.model.Model;
import najgl.texture.BitmapImage;
import najgl.util.Timer;
import org.lwjgl.opengl.GL;
import najgl.examples.ExampleModelLoader;

/**
 * A MilkshapeModel represents a Milkshape 3D model.  Currently, it can only
 * load the exported ascii text version of an MD3D model.  In the future, the
 * binary version may be supported, but there really is no need for it because
 * it does not matter how long it takes to load the animation.  Loading should
 * take place at game startup.  If speed becomes extremely important in the
 * future, the binary loader may be an option, or serialized models is another
 * option.  Unless someone contributes a binary loader or add the nehe lwjgl
 * port of the binary loader that actually loads multiple texture correctly :)
 *
 * The model can also draw itself, fully textured, to OpenGL through lwjgl.
 *
 * Bone animation is also supported.
 *
 * SPECIAL THANKS:
 * Animation method was ported by naj from a MSVC++ Model Viewer tutorial
 * written by Mete Ciragan (creator of Milkshape).
 *
 * @author naj
 * @version 0.1
 */
public class MilkshapeModel implements Model {

    /**
     * Debugging variable to toggle animations.
     */
    private boolean animated;

    /**
     * Debugging variable to toggle wireframe mode.
     */
    private boolean wireframe;

    /**
     * The total number of frames in the animation.
     */
    private int totalFrames;

    /**
     * The current frame of the animation.
     */
    private float currentFrame;

    /**
     * The number of meshes in the model.
     */
    private int numberMeshes;

    /**
     * The number of materials or textures in the model.
     */
    private int numberMaterials;

    /**
     * The number of joints or bones in the model.
     */
    private int numberJoints;

    /**
     * The meshes in the model.
     */
    private Mesh[] meshes;

    /**
     * The materials in the model.
     */
    private Material[] materials;

    /**
     * The joints in the model.
     */
    private Joint[] joints;

    /**
     * The absolute path to the directory containing the model file.  Used
     * to load the texture files.
     */
    private String absoluteFilePath;

    /**
     * A basic timer.
     */
    public static Timer timer = Timer.getTimer();

    public MilkshapeModel() {
        this.animated = false;
        this.wireframe = false;
    }

    public MilkshapeModel(boolean animated, boolean wireframe) {
        this.animated = animated;
        this.wireframe = wireframe;
    }

    /**
     * Draws the model to OpenGL via lwjgl.  Also advances the animation
     * frames along if there are animations for the model.
     */
    public void draw() {
        timer.tick();

        if (animated) {
            advanceFrame();
        }

        boolean isTextureEnabled = GL.glIsEnabled(GL.GL_TEXTURE_2D);

        for (int meshIndex = 0; meshIndex < numberMeshes; meshIndex++) {
            int materialIndex = meshes[meshIndex].materialIndex;

            if (materialIndex >= 0 && !wireframe) {
                ByteBuffer buffer = ByteBuffer.allocateDirect(16).order(ByteOrder.nativeOrder());

                GL.glMaterial(GL.GL_FRONT, GL.GL_AMBIENT, buffer.asFloatBuffer().put(materials[materialIndex].ambient));
                GL.glMaterial(GL.GL_FRONT, GL.GL_DIFFUSE, buffer.asFloatBuffer().put(materials[materialIndex].diffuse));
                GL.glMaterial(GL.GL_FRONT, GL.GL_SPECULAR, buffer.asFloatBuffer().put(materials[materialIndex].specular));
                GL.glMaterial(GL.GL_FRONT, GL.GL_EMISSION, buffer.asFloatBuffer().put(materials[materialIndex].emissive));
                GL.glMaterialf(GL.GL_FRONT, GL.GL_SHININESS, materials[materialIndex].shininess);

                if (materials[materialIndex].glTextureAddress > 0) {
                    GL.glBindTexture(GL.GL_TEXTURE_2D, materials[materialIndex].glTextureAddress);
                    GL.glEnable(GL.GL_TEXTURE_2D);
                } else {
                    GL.glDisable(GL.GL_TEXTURE_2D);
                }
            } else {
                GL.glDisable(GL.GL_TEXTURE_2D);
            }

            int triangleCount = meshes[meshIndex].numberTriangles;
            Vertex[] vertices = meshes[meshIndex].vertices;

            GL.glBegin(GL.GL_TRIANGLES);
            for (int triangleIndex = 0; triangleIndex < triangleCount; triangleIndex++) {
                Triangle triangle = (meshes[meshIndex].triangles)[triangleIndex];

                Vertex vertex = vertices[triangle.vertexIndex1];
                float[] normals = (meshes[meshIndex].normals)[triangle.normalIndex1];
                if (!animated || vertex.boneIndex == -1) {
                    GL.glNormal3f(normals[0], normals[1], normals[2]);
                    GL.glTexCoord2f(vertex.u, vertex.v);
                    GL.glVertex3f(vertex.x, vertex.y, vertex.z);
                } else {
                    Vector3f animationVector = new Vector3f();
                    Math.VectorRotate(new Vector3f(vertex.x, vertex.y, vertex.z), joints[vertex.boneIndex].finalMatrix, animationVector);
                    animationVector.x += joints[vertex.boneIndex].finalMatrix.m03;
                    animationVector.y += joints[vertex.boneIndex].finalMatrix.m13;
                    animationVector.z += joints[vertex.boneIndex].finalMatrix.m23;
                    GL.glNormal3f(normals[0], normals[1], normals[2]);
                    GL.glTexCoord2f(vertex.u, vertex.v);
                    GL.glVertex3f(animationVector.x, animationVector.y, animationVector.z);
                }

                vertex = vertices[triangle.vertexIndex2];
                normals = (meshes[meshIndex].normals)[triangle.normalIndex2];
                if (!animated || vertex.boneIndex == -1) {
                    GL.glNormal3f(normals[0], normals[1], normals[2]);
                    GL.glTexCoord2f(vertex.u, vertex.v);
                    GL.glVertex3f(vertex.x, vertex.y, vertex.z);
                } else {
                    Vector3f animationVector = new Vector3f();
                    Math.VectorRotate(new Vector3f(vertex.x, vertex.y, vertex.z), joints[vertex.boneIndex].finalMatrix, animationVector);
                    animationVector.x += joints[vertex.boneIndex].finalMatrix.m03;
                    animationVector.y += joints[vertex.boneIndex].finalMatrix.m13;
                    animationVector.z += joints[vertex.boneIndex].finalMatrix.m23;
                    GL.glNormal3f(normals[0], normals[1], normals[2]);
                    GL.glTexCoord2f(vertex.u, vertex.v);
                    GL.glVertex3f(animationVector.x, animationVector.y, animationVector.z);
                }

                vertex = vertices[triangle.vertexIndex3];
                normals = (meshes[meshIndex].normals)[triangle.normalIndex3];
                if (!animated || vertex.boneIndex == -1) {
                    GL.glNormal3f(normals[0], normals[1], normals[2]);
                    GL.glTexCoord2f(vertex.u, vertex.v);
                    GL.glVertex3f(vertex.x, vertex.y, vertex.z);
                } else {
                    Vector3f animationVector = new Vector3f();
                    Math.VectorRotate(new Vector3f(vertex.x, vertex.y, vertex.z), joints[vertex.boneIndex].finalMatrix, animationVector);
                    animationVector.x += joints[vertex.boneIndex].finalMatrix.m03;
                    animationVector.y += joints[vertex.boneIndex].finalMatrix.m13;
                    animationVector.z += joints[vertex.boneIndex].finalMatrix.m23;
                    GL.glNormal3f(normals[0], normals[1], normals[2]);
                    GL.glTexCoord2f(vertex.u, vertex.v);
                    GL.glVertex3f(animationVector.x, animationVector.y, animationVector.z);
                }
            }
            GL.glEnd();
        }

        if (isTextureEnabled && !wireframe) {
            GL.glEnable(GL.GL_TEXTURE_2D);
        } else {
            GL.glDisable(GL.GL_TEXTURE_2D);
        }
    }

    /**
     * Loads an ascii text model exported from MS3D.
     * @param filename the file to load.
     */
    public void load(String filename) {
        try {
            File file = new File(filename);
            absoluteFilePath = file.getAbsolutePath();
            absoluteFilePath = absoluteFilePath.substring(0, absoluteFilePath.lastIndexOf(File.separator) + 1);
            BufferedReader reader = new BufferedReader(new FileReader(file));
            String line;
            while ( (line = getNextLine(reader)) != null) {
                if (line.startsWith("Frames: ")) {
                    totalFrames = Integer.parseInt(line.substring(8));
                }
                if (line.startsWith("Frame: ")) {
                    currentFrame = Integer.parseInt(line.substring(7));
                }
                if (line.startsWith("Meshes: ")) {
                    numberMeshes = Integer.parseInt(line.substring(8));
                    meshes = new Mesh[numberMeshes];
                    parseMeshes(reader);
                }
                if (line.startsWith("Materials: ")) {
                    numberMaterials = Integer.parseInt(line.substring(11));
                    materials = new Material[numberMaterials];
                    parseMaterials(reader);
                }
                if (line.startsWith("Bones: ")) {
                    numberJoints = Integer.parseInt(line.substring(7));
                    joints = new Joint[numberJoints];
                    parseJoints(reader);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        reloadTextures();
    }

    /**
     * Simple parser to extract the mesh information from the text file.
     */
    private void parseMeshes(BufferedReader reader) throws Exception {
        for (int i = 0; i < numberMeshes; i++) {
            Mesh mesh = new Mesh();
            String line = getNextLine(reader);
            mesh.name = line.substring(1, line.lastIndexOf("\""));
            mesh.flags = Integer.parseInt(line.substring(line.lastIndexOf("\"") + 2, line.lastIndexOf(" ")));
            mesh.materialIndex = Integer.parseInt(line.substring(line.lastIndexOf(" ") + 1));

            line = getNextLine(reader);
            mesh.numberVertices = Integer.parseInt(line);
            Vertex[] vertices = new Vertex[mesh.numberVertices];
            for (int j = 0; j < mesh.numberVertices; j++) {
                line = getNextLine(reader);
                String[] values = line.split(" ");
                vertices[j] = new Vertex(Integer.parseInt(values[0]), Float.parseFloat(values[1]), Float.parseFloat(values[2]), Float.parseFloat(values[3]), Float.parseFloat(values[4]), Float.parseFloat(values[5]), Integer.parseInt(values[6]));
            }
            mesh.vertices = vertices;

            line = getNextLine(reader);
            mesh.numberNormals = Integer.parseInt(line);
            float[][] normals = new float[mesh.numberNormals][3];
            for (int j = 0; j < mesh.numberNormals; j++) {
                line = getNextLine(reader);
                String[] values = line.split(" ");
                normals[j] = new float[] {
                    Float.parseFloat(values[0]), Float.parseFloat(values[1]), Float.parseFloat(values[2])};
            }
            mesh.normals = normals;

            line = getNextLine(reader);
            mesh.numberTriangles = Integer.parseInt(line);
            Triangle[] triangles = new Triangle[mesh.numberTriangles];
            for (int j = 0; j < mesh.numberTriangles; j++) {
                line = getNextLine(reader);
                String[] values = line.split(" ");
                triangles[j] = new Triangle(Integer.parseInt(values[0]), Integer.parseInt(values[1]), Integer.parseInt(values[2]), Integer.parseInt(values[3]), Integer.parseInt(values[4]), Integer.parseInt(values[5]), Integer.parseInt(values[6]), Integer.parseInt(values[7]));
            }
            mesh.triangles = triangles;
            meshes[i] = mesh;
        }
    }

    /**
     * Simple parser to extract the material information from the text file.
     */
    private void parseMaterials(BufferedReader reader) throws Exception {
        for (int i = 0; i < numberMaterials; i++) {
            String line = getNextLine(reader);
            Material material = new Material();
            material.name = line.substring(1, line.length() - 1);
            line = getNextLine(reader);
            String[] values = line.split(" ");
            material.ambient = new float[] {
                Float.parseFloat(values[0]), Float.parseFloat(values[1]), Float.parseFloat(values[2]), Float.parseFloat(values[3])};
            line = getNextLine(reader);
            values = line.split(" ");
            material.diffuse = new float[] {
                Float.parseFloat(values[0]), Float.parseFloat(values[1]), Float.parseFloat(values[2]), Float.parseFloat(values[3])};
            line = getNextLine(reader);
            values = line.split(" ");
            material.specular = new float[] {
                Float.parseFloat(values[0]), Float.parseFloat(values[1]), Float.parseFloat(values[2]), Float.parseFloat(values[3])};
            line = getNextLine(reader);
            values = line.split(" ");
            material.emissive = new float[] {
                Float.parseFloat(values[0]), Float.parseFloat(values[1]), Float.parseFloat(values[2]), Float.parseFloat(values[3])};
            line = getNextLine(reader);
            material.shininess = Float.parseFloat(line);
            line = getNextLine(reader);
            material.transparency = Float.parseFloat(line);
            line = getNextLine(reader);
            material.colorMap = line.substring(1, line.length() - 1);
            line = getNextLine(reader);
            material.alphaMap = line.substring(1, line.length() - 1);
            materials[i] = material;
        }
    }

    /**
     * Simple parser to extract the joint information from the text file.
     */
    private void parseJoints(BufferedReader reader) throws Exception {
        for (int i = 0; i < numberJoints; i++) {
            String line = getNextLine(reader);
            Joint joint = new Joint();
            joint.name = line.substring(1, line.length() - 1);
            line = getNextLine(reader);
            joint.parentName = line.substring(1, line.length() - 1);
            line = getNextLine(reader);
            String[] values = line.split(" ");
            joint.flags = Integer.parseInt(values[0]);
            joint.posx = Float.parseFloat(values[1]);
            joint.posy = Float.parseFloat(values[2]);
            joint.posz = Float.parseFloat(values[3]);
            joint.rotx = Float.parseFloat(values[4]);
            joint.roty = Float.parseFloat(values[5]);
            joint.rotz = Float.parseFloat(values[6]);
            line = getNextLine(reader);
            joint.numberPosistionKeyframes = Integer.parseInt(line);
            Keyframe[] positionKeyframes = new Keyframe[joint.numberPosistionKeyframes];
            for (int j = 0; j < joint.numberPosistionKeyframes; j++) {
                line = getNextLine(reader);
                values = line.split(" ");
                positionKeyframes[j] = new Keyframe(Float.parseFloat(values[0]), Float.parseFloat(values[1]), Float.parseFloat(values[2]), Float.parseFloat(values[3]));
            }
            joint.positionKeys = positionKeyframes;
            line = getNextLine(reader);
            joint.numberRotationKeyframes = Integer.parseInt(line);
            Keyframe[] rotationKeyframes = new Keyframe[joint.numberRotationKeyframes];
            for (int j = 0; j < joint.numberRotationKeyframes; j++) {
                line = getNextLine(reader);
                values = line.split(" ");
                rotationKeyframes[j] = new Keyframe(Float.parseFloat(values[0]), Float.parseFloat(values[1]), Float.parseFloat(values[2]), Float.parseFloat(values[3]));
            }
            joint.rotationKeys = rotationKeyframes;
            joints[i] = joint;

            int parentIndex = -1;
            if (joints[i].parentName.length() > 0) {
                for (int j = 0; j < numberJoints; j++) {
                    if (joints[j].name.equalsIgnoreCase(joints[i].parentName)) {
                        parentIndex = j;
                        break;
                    }
                }
                if (parentIndex == -1) {
                    System.out.println("CRAP!");
                    System.exit(1);
                }
            }
            joints[i].parentIndex = parentIndex;
        }
        if (animated) {
            setupJointAnimations();
        }
    }

    /**
     * Calculate the initial absolute and relative matrices for the joints.
     */
    private void setupJointAnimations() {
        for (int jointIndex = 0; jointIndex < numberJoints; jointIndex++) {
            Joint joint = joints[jointIndex];
            Vector3f rotationVector = new Vector3f();
            rotationVector.x = joint.rotx * 180 / (float) Math.PI;
            rotationVector.y = joint.roty * 180 / (float) Math.PI;
            rotationVector.z = joint.rotz * 180 / (float) Math.PI;
            Math.AngleMatrix(rotationVector, joints[jointIndex].relativeMatrix);
            joints[jointIndex].relativeMatrix.m03 = joint.posx;
            joints[jointIndex].relativeMatrix.m13 = joint.posy;
            joints[jointIndex].relativeMatrix.m23 = joint.posz;
            if (joint.parentIndex != -1) {
                Math.R_ConcatTransforms(joints[joint.parentIndex].absoluteMatrix, joints[jointIndex].relativeMatrix, joints[jointIndex].absoluteMatrix);
                joints[jointIndex].finalMatrix.copy(joints[jointIndex].absoluteMatrix);
            } else {
                joints[jointIndex].absoluteMatrix.copy(joints[jointIndex].relativeMatrix);
                joints[jointIndex].finalMatrix.copy(joints[jointIndex].relativeMatrix);
            }
        }

        for (int meshIndex = 0; meshIndex < numberMeshes; meshIndex++) {
            Mesh pMesh = meshes[meshIndex];
            for (int j = 0; j < pMesh.numberVertices; j++) {
                Vertex vertex = pMesh.vertices[j];
                if (vertex.boneIndex != -1) {
                    vertex.x -= joints[vertex.boneIndex].absoluteMatrix.m03;
                    vertex.y -= joints[vertex.boneIndex].absoluteMatrix.m13;
                    vertex.z -= joints[vertex.boneIndex].absoluteMatrix.m23;
                    Vector3f inverseRotationVector = new Vector3f();
                    Math.VectorIRotate(new Vector3f(vertex.x, vertex.y, vertex.z), joints[vertex.boneIndex].absoluteMatrix, inverseRotationVector);
                    vertex.x = inverseRotationVector.x;
                    vertex.y = inverseRotationVector.y;
                    vertex.z = inverseRotationVector.z;
                }
            }
        }
    }

    /**
     * Set the final matrix of all of the joints to be part way between the
     * previous keyframe and the next keyframe, depending on how much time
     * has passed since the last keyframe.
     */
    private void advanceFrame() {
        /* FIXME: The current frame needs to be determined by what milkshape
                  model defined, not a constant value as below... otherwise,
                  animations are going to be out of synch on different fps
                  systems and animations with different numbers of frames */
        currentFrame += ExampleModelLoader.dt;
        if (currentFrame > totalFrames) {
            currentFrame = 0.0f;
        }

        for (int meshIndex = 0; meshIndex < numberJoints; meshIndex++) {
            Joint joint = joints[meshIndex];
            int positionKeyframeCount = joint.numberPosistionKeyframes;
            int rotationKeyframeCount = joint.numberRotationKeyframes;
            if (positionKeyframeCount == 0 && rotationKeyframeCount == 0) {
                joints[meshIndex].finalMatrix.copy(joints[meshIndex].absoluteMatrix);
            } else {
                Vector3f positionVector = new Vector3f();
                Vector4f rotationVector = new Vector4f();
                Keyframe lastPositionKeyframe = null;
                Keyframe currentPositionKeyframe = null;
                for (int keyframeIndex = 0; keyframeIndex < positionKeyframeCount; keyframeIndex++) {
                    Keyframe positionKeyframe = joint.positionKeys[keyframeIndex];
                    if (positionKeyframe.time >= currentFrame) {
                        currentPositionKeyframe = positionKeyframe;
                        break;
                    }
                    lastPositionKeyframe = positionKeyframe;
                }
                if (lastPositionKeyframe != null && currentPositionKeyframe != null) {
                    float d = currentPositionKeyframe.time - lastPositionKeyframe.time;
                    float s = (currentFrame - lastPositionKeyframe.time) / d;
                    positionVector.x = lastPositionKeyframe.x + (currentPositionKeyframe.x - lastPositionKeyframe.x) * s;
                    positionVector.y = lastPositionKeyframe.y + (currentPositionKeyframe.y - lastPositionKeyframe.y) * s;
                    positionVector.z = lastPositionKeyframe.z + (currentPositionKeyframe.z - lastPositionKeyframe.z) * s;
                } else if (lastPositionKeyframe == null) {
                    currentPositionKeyframe.x = positionVector.x;
                    currentPositionKeyframe.y = positionVector.y;
                    currentPositionKeyframe.z = positionVector.z;
                } else if (currentPositionKeyframe == null) {
                    lastPositionKeyframe.x = positionVector.x;
                    lastPositionKeyframe.y = positionVector.y;
                    lastPositionKeyframe.z = positionVector.z;
                }
                Matrix34f slerpedMatrix = new Matrix34f();
                Keyframe lastRotationKeyframe = null;
                Keyframe currentRotationKeyframe = null;
                for (int keyframeIndex = 0; keyframeIndex < rotationKeyframeCount; keyframeIndex++) {
                    Keyframe rotationKeyframe = joint.rotationKeys[keyframeIndex];
                    if (rotationKeyframe.time >= currentFrame) {
                        currentRotationKeyframe = rotationKeyframe;
                        break;
                    }
                    lastRotationKeyframe = rotationKeyframe;
                }
                if (lastRotationKeyframe != null && currentRotationKeyframe != null) {
                    float d = currentRotationKeyframe.time - lastRotationKeyframe.time;
                    float s = (currentFrame - lastRotationKeyframe.time) / d;
                    Vector4f slerpedQuaternion = new Vector4f();
                    Vector4f lastRotationQuaternion = new Vector4f();
                    Vector4f currentRotationQuaternion = new Vector4f();
                    Math.AngleQuaternion(new Vector3f(lastRotationKeyframe.x, lastRotationKeyframe.y, lastRotationKeyframe.z), lastRotationQuaternion);
                    Math.AngleQuaternion(new Vector3f(currentRotationKeyframe.x, currentRotationKeyframe.y, currentRotationKeyframe.z), currentRotationQuaternion);
                    Math.QuaternionSlerp(lastRotationQuaternion, currentRotationQuaternion, s, slerpedQuaternion);
                    Math.QuaternionMatrix(slerpedQuaternion, slerpedMatrix);
                } else if (lastRotationKeyframe == null) {
                    rotationVector.x = currentRotationKeyframe.x * 180 / (float) Math.PI;
                    rotationVector.y = currentRotationKeyframe.y * 180 / (float) Math.PI;
                    rotationVector.z = currentRotationKeyframe.z * 180 / (float) Math.PI;
                    Math.AngleMatrix(new Vector3f(rotationVector.x, rotationVector.y, rotationVector.z), slerpedMatrix);
                } else if (currentRotationKeyframe == null) {
                    rotationVector.x = lastRotationKeyframe.x * 180 / (float) Math.PI;
                    rotationVector.y = lastRotationKeyframe.y * 180 / (float) Math.PI;
                    rotationVector.z = lastRotationKeyframe.z * 180 / (float) Math.PI;
                    Math.AngleMatrix(new Vector3f(rotationVector.x, rotationVector.y, rotationVector.z), slerpedMatrix);
                }
                slerpedMatrix.m03 = positionVector.x;
                slerpedMatrix.m13 = positionVector.y;
                slerpedMatrix.m23 = positionVector.z;
                Math.R_ConcatTransforms(joints[meshIndex].relativeMatrix, slerpedMatrix, joints[meshIndex].relativeFinalMatrix);
                if (joint.parentIndex == -1) {
                    joints[meshIndex].finalMatrix.copy(joints[meshIndex].relativeFinalMatrix);
                } else {
                    Math.R_ConcatTransforms(joints[joint.parentIndex].finalMatrix, joints[meshIndex].relativeFinalMatrix, joints[meshIndex].finalMatrix);
                }
            }
        }

    }

    /**
     * Returns the next line from the text file being parsed.  Removes
     * comments and trims the line of whitespace.
     */
    private String getNextLine(BufferedReader reader) throws Exception {
        String line = null;
        while ( (line = reader.readLine()) != null) {
            line = line.trim();
            if (line.startsWith("//") || "".equals(line)) {
                continue;
            }
            break;
        }
        return line;
    }

    /**
     * Reloads the textures.
     */
    private final void reloadTextures() {
        for (int i = 0; i < numberMaterials; i++) {
            if (materials[i].name.length() > 0) {
                try {
                    materials[i].glTextureAddress = loadTexture(absoluteFilePath + materials[i].name);
                } catch (Exception e) {
                    materials[i].glTextureAddress = 0;
                }
            } else {
                materials[i].glTextureAddress = 0;
            }
        }
    }

    /**
     * Loads a bitmap (*.bmp image file) texture in opengl memory
     * @param the relative filename to the bmp
     * @return the image address in memory
     */
    private final int loadTexture(String file) throws Exception {
        Image image = BitmapImage.loadImage(new FileInputStream(file), file);

        // Exctract the image
        BufferedImage textureImage = new BufferedImage(image.getWidth(null), image.getHeight(null), BufferedImage.TYPE_3BYTE_BGR);
        Graphics2D textureGraphics = (Graphics2D) textureImage.getGraphics();
        textureGraphics.drawImage(image, null, null);
        textureGraphics.dispose();

        // Put the image in memory
        ByteBuffer scratch = ByteBuffer.allocateDirect(4 * textureImage.getWidth() * textureImage.getHeight()).order(ByteOrder.nativeOrder());
        byte data[] = (byte[]) textureImage.getRaster().getDataElements(0, 0, textureImage.getWidth(), textureImage.getHeight(), null);
        scratch.clear();
        scratch.put(data);
        scratch.flip();

        // Pass the image off to opengl
        IntBuffer buffer = ByteBuffer.allocateDirect(4).order(ByteOrder.nativeOrder()).asIntBuffer();
        GL.glGenTextures(buffer);
        GL.glBindTexture(GL.GL_TEXTURE_2D, buffer.get(0));
        GL.glTexParameteri(GL.GL_TEXTURE_2D, GL.GL_TEXTURE_MIN_FILTER, GL.GL_LINEAR);
        GL.glTexParameteri(GL.GL_TEXTURE_2D, GL.GL_TEXTURE_MAG_FILTER, GL.GL_LINEAR);
        GL.glTexImage2D(GL.GL_TEXTURE_2D, 0, GL.GL_RGB, textureImage.getWidth(), textureImage.getHeight(), 0, GL.GL_RGB, GL.GL_UNSIGNED_BYTE, scratch);

        // Return Image Address In Memory
        return buffer.get(0);
    }


    /* FIXME: these methods do not change the state of opengl so they can not
              be used on the fly to change between modes since the opengl
              state is currently created in the init method */

    /**
     * Determine is the model is going to run animations, if it has them.
     * @return the animation mode.
     */
    public boolean isAnimated() {
        return animated;
    }

    /**
     * Set the new animation mode.
     * @param animated the new animation mode.
     */
    public void setAnimated(boolean animated) {
        this.animated = animated;
    }

    /**
     * Determine is the model is in wireframe mode.
     * @return the wireframe mode.
     */
    public boolean isWireframe() {
        return wireframe;
    }

    /**
     * Set the wireframe mode.
     * @param wireframe the new wireframe mode.
     */
    public void setWireframe(boolean wireframe) {
        this.wireframe = wireframe;
    }

}