/* * Copyright (c) 2003-2008 jMonkeyEngine * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are * met: * * * Redistributions of source code must retain the above copyright *   notice, this list of conditions and the following disclaimer. * * * Redistributions in binary form must reproduce the above copyright *   notice, this list of conditions and the following disclaimer in the *   documentation and/or other materials provided with the distribution. * * * Neither the name of 'jMonkeyEngine' nor the names of its contributors  *   may be used to endorse or promote products derived from this software  *   without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */package com.jmex.swt.input;import java.awt.Component;import java.net.URL;import java.util.BitSet;import org.eclipse.swt.events.MouseEvent;import org.eclipse.swt.events.MouseListener;import org.eclipse.swt.events.MouseMoveListener;import org.eclipse.swt.events.MouseTrackListener;import org.eclipse.swt.graphics.Point;import org.eclipse.swt.widgets.Display;import org.eclipse.swt.widgets.Event;import org.eclipse.swt.widgets.Listener;import com.jme.image.Image;import com.jme.input.MouseInput;import com.jme.input.MouseInputListener;/** * Note: portions originally from the jme-swt source. */public class SWTMouseInput extends MouseInput implements MouseTrackListener,		MouseListener, MouseMoveListener, Listener {	private boolean enabled = true;	private BitSet buttons = new BitSet(3);	private Point absPoint = new Point(0,0);	private Point lastPoint = new Point(Integer.MIN_VALUE, Integer.MIN_VALUE);	private Point currentDeltaPoint = new Point(0,0);	private Point deltaPoint = new Point(0,0);	private Point lastCursorPosition;	private Component deltaRelative;	private boolean fixedposition=false;	private int lastWheelRotation;	private int wheelDelta;	private int wheelRotation;	private boolean doubleclick=false;	@Override	protected void destroy() {		// TODO Auto-generated method stub	}	public boolean isEnabled() {		return enabled;	}	/**	 * @param enabled The enabled to set.	 */	public void setEnabled(boolean enabled) {		this.enabled = enabled;	}	@Override	public int getButtonCount() {		return 3;	}	@Override	public int getButtonIndex(String buttonName) {		if ("MOUSE0".equalsIgnoreCase(buttonName)) return 0;		else if ("MOUSE1".equalsIgnoreCase(buttonName)) return 1;		else if ("MOUSE2".equalsIgnoreCase(buttonName)) return 2;		throw new IllegalArgumentException("invalid buttonName: "+buttonName);	}	@Override	public String getButtonName(int buttonIndex) {		switch (buttonIndex) {		case 0:			return "MOUSE0";		case 1:			return "MOUSE1";		case 2:			return "MOUSE2";		}		throw new IllegalArgumentException("invalid buttonIndex: "+buttonIndex);	}	public int getXDelta() {		if (deltaRelative != null) {			if (!enabled) return 0;			int rVal = (deltaRelative.getWidth() / 2) - absPoint.x;			return (int)(rVal * -0.01f);		} 		return deltaPoint.x;        	}	public int getXAbsolute() {		return absPoint.x;	}	public int getYAbsolute() {		return absPoint.y;	}	public int getYDelta() {		if (deltaRelative != null) {			if (!enabled) return 0;			int rVal = (deltaRelative.getHeight() / 2) - absPoint.y;			return (int)(rVal * 0.05f);		} 		return deltaPoint.y;        	}	/**	 * Swing events are put in here in the swing thread and removed from it in the update method.	 * To flatline memory usage the LinkedList could be replaced by two ArrayLists but then one	 * would need to synchronize insertions.	 */	//private List<MouseEvent> swtEvents = new LinkedList<MouseEvent>();	private boolean b1waspressed=false;	private boolean b2waspressed=false;	private boolean b3waspressed=false;	/**	 * x position of last event that was processed by {@link #update}	 */	private int lastEventX;	/**	 * y position of last event that was processed by {@link #update}	 */	private int lastEventY;	public void update() {		int x = lastEventX;		int y = lastEventY;		if ( listeners == null || listeners.isEmpty() ) {			return;		}		for ( int i = 0; i < listeners.size(); i++ ) {			MouseInputListener listener=listeners.get(i);			if(lastPoint.x!=x || lastPoint.y!=y) {				listener.onMove( lastPoint.x - x, y - lastPoint.y, lastPoint.x, lastPoint.y );  			}			if( buttons.get(0)!=b1waspressed) {				listener.onButton( 1, buttons.get(0), lastPoint.x, lastPoint.y);			}			if(buttons.get(1)!=b2waspressed) {				listener.onButton( 2, buttons.get(1), lastPoint.x, lastPoint.y);			}			if(buttons.get(2)!=b3waspressed) {				listener.onButton( 3, buttons.get(2), lastPoint.x, lastPoint.y);			}			if(wheelRotation!=lastWheelRotation) {				listener.onWheel( wheelRotation, lastPoint.x, lastPoint.y);				lastWheelRotation=wheelRotation;			}			if (doubleclick && (listener instanceof SWTMouseInputListener)) {				((SWTMouseInputListener) listener).onDoubleClick(lastPoint.x, lastPoint.y);			}		}		b1waspressed=buttons.get(0);		b2waspressed=buttons.get(1);		b3waspressed=buttons.get(2);		lastEventX = x;		lastEventY = y;		deltaPoint.x=currentDeltaPoint.x;		deltaPoint.y=currentDeltaPoint.y;		currentDeltaPoint.x=0;		currentDeltaPoint.y=0;		doubleclick = false;	}	@Override	public boolean isButtonDown(int buttonCode) {		return buttons.get(buttonCode);	}	@Override	public boolean isCursorVisible() {		// TODO Auto-generated method stub		return true;	}	@Override	public void setCursorPosition(int x, int y) {		absPoint.x=x;		absPoint.y=y;	}	@Override	public void setCursorVisible(boolean v) {		// TODO Auto-generated method stub	}	public void mouseEnter(MouseEvent arg0) {		//don't make sudden movements. Is this wise? I don't know, but 1st 		//person handler does not work without this		lastPoint.x=arg0.x;		lastPoint.y=arg0.y;	}	public void mouseExit(MouseEvent arg0) {		// TODO Auto-generated method stub	}	public void mouseHover(MouseEvent arg0) {		// TODO Auto-generated method stub	}	public void mouseDoubleClick(MouseEvent arg0) {		if (!enabled) return;		doubleclick = true;	}	public void mouseDown(MouseEvent arg0) {		if (!enabled) return;		lastPoint.x=arg0.x;		lastPoint.y=arg0.y;		buttons.set(arg0.button-1, true);	}	public void mouseUp(MouseEvent arg0) {				if (!enabled) return;		currentDeltaPoint.x=0;		currentDeltaPoint.y=0;		if (deltaRelative != null) {			absPoint.x = deltaRelative.getWidth() >> 1;		absPoint.y = deltaRelative.getHeight() >> 1;		}		buttons.set(arg0.button-1, false);	}	public void setFixed(boolean fixed) {		fixedposition=fixed;		lastCursorPosition=Display.getCurrent().getCursorLocation();	}	public void setFixed(boolean fixed, Point reentry) {		fixedposition=fixed;		lastCursorPosition=reentry;	}	public void mouseMove(MouseEvent arg0) {		if (!enabled) return;		absPoint.x=arg0.x;		absPoint.y=arg0.y;		if (lastPoint.x == Integer.MIN_VALUE) {			lastPoint.x=absPoint.x;			lastPoint.y=absPoint.y;		}		if(fixedposition) {			currentDeltaPoint.x = -(absPoint.x-lastPoint.x);			currentDeltaPoint.y =  (absPoint.y-lastPoint.y);		} else {			currentDeltaPoint.x = absPoint.x-lastPoint.x;			currentDeltaPoint.y = -(absPoint.y-lastPoint.y);		}		lastPoint.x= arg0.x;		lastPoint.y= arg0.y;		if(fixedposition) {			Display.getCurrent().setCursorLocation(lastCursorPosition);		} 	}	//mouse wheel	public void handleEvent(Event event){		if (!enabled) return;		int c = event.count;		c = (int) Math.ceil(c / 3.0f);		wheelDelta=0;		while (c < 0)		{			wheelDelta--;			wheelRotation --;			c++;		}		while (c > 0)		{			wheelDelta++;			wheelRotation++;			c--;		}	} 	@Override	public int getWheelDelta() {		return wheelDelta;	}	@Override	public int getWheelRotation() {		return wheelRotation;	}	@Override	public void setHardwareCursor(URL file) {        ; // ignore	}	@Override	public void setHardwareCursor(URL file, int xHotspot, int yHotspot) {        ; // ignore	}    @Override    public void setHardwareCursor(URL file, Image[] images, int[] delays, int xHotspot, int yHotspot) {        ; // ignore    }    public void clear() {    	this.buttons.clear();    }        public void clearButton(int buttonCode) {    	buttons.set(buttonCode, false);    }}