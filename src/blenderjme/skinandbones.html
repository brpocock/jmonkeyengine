<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<!-- $Id$ -->
<HTML>
  <HEAD>
    <TITLE>Skin &amp; Bones Exporting</TITLE>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
<html>
<head>
    <STYLE>
      body, table, div {
          font-family:sans-serif:0;
          font-size:14px;
          border:0;
          padding:0;
      }
      table, div {
          margin:0;
      }
      .gotcha { background-color:orange; }
      body { background-color:white; margin:10px; }
      code { font-family:monospace; }
      table.data { background-color:silver; }
      table.data td, table.data th { border:solid gray 1px; }
      th { font-size:80%; }
      td, th { padding:3px; }
      tr.odd td { background-color:#E6E6FA; }
      tr.even td { background-color:#E0FFFF; }
      li { margin-top:3; margin-bottom:3px; }
      div.footer { font-size:12px; }
      span.addr { font-style:italic; white-space:nowrap; }
      a { color:black; }
    </STYLE>
  </HEAD>
  <BODY>
    <h3>Skin &amp; Bones Exporting with<br/>
      Blender &#x21d2; jME Exporter</h3>
    Covers version ${product.version}.
    <BR/>
    Copyright 2009 by Blaine Simpson and the jME Dev Team,
    with the included BSD open source license.
    <HR/>
    <h4 id="contents">Contents</h4>
    <ol>
      <li><a href="#purpose">Purpose</a>
      <li><a href="constraints">Constraints</a>
      <li><a href="procedure">Conventional Skin &amp; Bones Export Procedure</a>
      <li><a href="tips">Tips</a>
    </ol>
    <a href="exporter.html">Main Help Page</a>
    <HR/>
    <h4 id="purpose">Purpose</h4>
    <p>
    This document <ol>
      <li>explains the constraints that your scene must satisfy in
      order to be exported
      <li>describes the steps needed to create and export a conventional
      Blender Skin &amp; Bones animation
      <li>Lists some important, non-intuitive aspects of this exporter
      and of Skin &amp; Bones animation in general.
    </ol>
    </p> <p>
    The exporter supports many Armature use cases in addition to the one
    described here.  I intend to write tutorials covering the most useful of
    these, so look for them <A target="other_frame"
    href="http://www.jmonkeyengine.com/wiki/doku.php?id=the_tutorials_-_jme_2">
    on the jME Wiki</A>.
    </p>
    <HR/>
    <h4 id="constraints">Constraints</h4>
      <UL>
        <LI>By far the worse bug in the exporter is that transforms generated
          for non-deforming Mesh Object children of Armature bones are so bad
          as to be unusable.
          We are talking about non-skin children of bones here.
          It's not uncommon to parent eyes or teeth directly to bones.
          If you do that in Blender, it may or may not transfer to jME
          correctly.
          Until somebody figures out how to get these transforms to behave, the
          work-around is to not export these child objects as children of the
          bones, and to attach them on the jME side.
          Due to the differences between jME and Blender, this means you'll
          have to use a tool like Modeler or SceneMonitor to figure out the
          needed offset and rotation relative to the parenting bone.
          Since this is basic information needed to reconstitute your model in
          jME, you may want to keep the rotation and translation values with
          your model.
          I do this by setting Blender game properties of type float.
          These can be retrieved in jME with
          <code>Node.getUserData("floatSpatialAppAttrs").get("yourPropName")</code>.
        <LI>Armatures must be at the root level
        <LI>We haven't yet figured out the exact criteria, but bone weighting
          problems can arise if you never apply Bone Heat to your skin.
          You can modify the weightings as much as you wish afterwards, but in
          some cases, you must apply Bone Heat once.
          If you have no reason to avoid it (like you don't want to change
          pre-existing weightings), make sure to apply Bone Heat.
        <LI>Armatures may only have one bone-weighted skin.
        <LI>All bones in a single export must be named uniquely.
        If you export 4 armatures with 10 bones each, you need 40 unique bone
        names.
        (You could avoid this constraint by making 4 separate exports).
        <LI>The skin mesh object must have no scale or rotation.
        You can easily accommodate this by using CTRL-A on the skin, in Object
        mode.  If you want your model saved <i>with</i> skin mesh scaling or
        rotation, then just don't save after this operation.
        This operation to remove scale and rotation doesn't break existing bone
        weightings or actions.
        <LI>On the jME side, animations will interpolate <i>linearly</i>
        between key frames, regardless of what interpolation algorithm Blender
        uses.
        This is a limitation of <code>com.jme.animation</code>.
        <LI>As suggested in Blender documentation, the skin Object and the
        Armature Object should both have zero rotations and scale values of 1;
        and the translation (location) of these two objects should be exactly
        the same.
      </UL>
      Any or all of these constraints may be removed as we improve the
        exporter.
    <HR/>
    <h4 id="procedure">Conventional Skin &amp; Bones Export Procedure</h4>
    This section describes the procedure, but it is not a tutorial,
    Advanced Blender and jME users will probably learn a lot from reading this
    section.
    Beginners may want to start by looking for a tutorial <A target="oth_frame"
    href="http://www.jmonkeyengine.com/wiki/doku.php?id=the_tutorials_-_jme_2">
    on the jME Wiki</A>, then returning here once you have a grasp on the work
    flow.
    <ol>
      <li>Obtain or create, and prepare your skin mesh Object.
        <ul>
          <li>If your skin is composed of multiple meshes, join them into a
          single mesh with Ctrl-J.
          <li>If you start your skin object with very low vertex polies, you
          will need to add more vertexes around joints so that skin
          deformations will result in smooth skin curves.
          One way that is often efficient and easy is to go into
          EDIT mode and use A and B to select just Edges around the joints,
          then W Subdivide Multi.
          You may need to move your view around to get orthogonal to the
          desired edges to select just the ones you want.
          If you want to use the same multiplier on multiple areas, you can
          select edges for all of these joints and perform a single Subdivide
          Multi.
          <li>Eliminate any rotation or scaling to your skin Object by
          selecting it, Ctrl-A, "Scale and Rotation to ObjData".
          (This can be done any time before the export.
          If you want your model saved with scale or rotation, then postpone
          this step to immediately before you write the export).
        </ul>
      <li>Create your skeleton.
        <ul>
          <li>Set insertion cursor on the skin mesh location.
          While the skin mesh Object is selected, do SHIFT-S, Cursor->Selection.
          <li>Pulldown Add / Armature.
          <b>Do not do anything to the new bone or Arma yet!</b>
          <li>In the Mesh button panel, click on the Armature "X-Ray" toggle so
          that you will be able to see the bone inside of the skin.
          Rename the root bone if you wish to.
          <li>Position and size the root bone.
          In EDIT mode, select the Bone (not the armature or anything else!)
          and move it to position the Root end where you want it.
          Don't worry about the tip or the bone size: we'll take care of that
          next.
          In most cases you will want your bone location to stay aligned with
          an axis of the body/armature base.
          To move the bone while keeping it aligned on that axis, select the
          Bone (in EDIT mode), hit "g", hit "z" to lock movement on the Z axis
          (or X for X axis, etc.).
          To scale and rotate the bone, you just move the tip:
          Select just the Bone Tip and move it in the same exact way that
          you just moved the Root.
          You can use R to rotate bones, but 99% of the time it's easier to
          place the Root where you want it, then position the Tip to set
          rotation and size.
          <li>Extract all other bones by hitting "e" and positioning new Bone
          Tips in EDIT mode.
          <li>Often, you will want a couple Roots to not be directly connected
          to their parent.
          To do this, just select the bone and toggle off "Co" in the Armature
          Bones panel.
          You can then position this bone without effecting the Tip of the
          parent bone.
          <p class="gotcha">
          <b>GOTCHA:</b> I have to select another bone and go back in order for
          this to take effect.</p>
          <li>To create additional root bones (one often wants independent root
          bones for spine and eyes or thighs or shoulders), select an existing
          root bone's Root and extract from that.
          You can, alternatively, extrude the bone from anywhere, then select
          it and in the Armature Bones panel use the "child of" pulldown to set
          the parent bone to nothing.
          <p class="gotcha">
          <b>GOTCHA:</b> I have to select another bone and go back in order for
          either of these tactics to take effect.</p>
          <li>To create more than one children bones of any bone, select the
          Root of any existing bone (one that you want to create a peer of),
          and E to extrude from that.
          <li class="gotchae"> 
          <b>GOTCHA:</b>  It is very easy to accidentally create extra bones
          that you can't see.
          I keep an eye on the Outliner View to prevent this.</li>
          <li>Name your Bones appropriately.
          There are several ways to do this.
          I prefer to do (nearly) all of my item renaming by Ctrl-clicking on
          the names in the Outliner View.
          <li>As always in any 3D visualizer, make sure to view placements from
          at least two orthogonal positions.
        </ul>
      <li>Initialize Bone Weights to skin vertexes.
      <p style="font-family:mono-space;">
    [You can accomplish the same thing as described in this section by just
    parenting the skin Object to the armature Object and choosing Bone Heat
    when prompted, then perform bone weighting adjustment as described below.
    I explain the Modifier method because this seems to be the procedure
    recommended by the most recent Blender docs.]</p>

      <ul>
        <li>Before using any system that generates skin/bone weights
        automatically, make sure to toggle off the <code>Deform</code>
        property of all bones that you do not want to influence the skin mesh.
        This is done by selecting each bone in Edit mode and clicking the
        toggle in the Mesh Button window's Armature Bones panel.
        <li>Create an "Armature" modifier for the skin mesh, and key in the
        precise name of the Armature object in the "Ob:" field.
        Pay attention that you enter the "Object" name here, not the name of
        the Armature itself (which is its child).
        <span style="font-family:mono-space;">
        [It would be great if they supplied a pulldown populated with just the
        appropriate Object names.  Maybe some day.]</span>
      <li>De-select the "Envelopes" option.
      You can convert from envelopes to vertex groups, but unless you are
      starting with a model that already has envelopes, just stick with the
      Vert. Groups option.
      Eventually, you must have vertexes weighted by Vertex Groups, since that
      is how the exporter (and most other programs other than Blender itself)
      apply the specified weights.
      <li>This step consists of one of the quirkiest operations in Blender.
      First, select the Armature object and switch to pose mode.
      Blender remembers this as the "current" mode for the Armature even when
      you select another object.
      Now, select the skin mesh and switch to Weight Paint mode.
      Now, due to the Armature being in pose mode, you can skin weight painter
      knows about the bones.
      <p class="gotcha">
      <b>IMPORTANT!</b>
      For the time being, you must apply "bone heats" to your model.
      This is a work-around which prevents artifacts from wrecking the export.
      When we have time to dig into the issue and fix the real problem, we'll
      eliminate this requirement.</p>
      <li>Right click on any bone.
      Click "w" and choose "Apply Bone Heat...".
      Repeat this operation until you have applied Bone Heat to each bone.
      (The Weight Paint interface doesn't allow you to select multiple bones at
      once :( ).
      Though you are allowed to paint weights for non-Deform bones, such
      weightings will never be applied to a mesh.
    </ul>
  <li>Adjust Bone Weights
    <p>
    You can adjust bone weights anytime.
    It may well be the case that the automatic bone heat weightings are
    adequate for your model, and you don't need to make any adjustments.
    </p><p>
    You must enter the Weight Paint editor as described in the previous step,
    so that Blender can associate the skin vertexes with the bones.
    Select bones and rotate them.
    I like to use R to do that.
    See whether you are satisfied with the skin deformations.
    <p>
    <ul>
      <li>Click "n", which just duplicates the Paint button panel up in the
      Weight Paint Viewer.
      With the controlling bone selected, "Add" or "Remove" bone weight
      to pixels by painting.
      The closer to Red, the more the selected bone influences.
      The closer to Blue, the less the selected bone influences.
    </ul>
  <li>Export
    <ul>
      <li>Save your scene, in case something crashes and hoses it.
      Just like most (or all) exporters that handle animations, this exporter
      does work with your scene objects in order to gather the data it needs.
      <li>Make sure to select both the skin mesh object and the armature object
      from Object mode.
      <li>Hit the <code>Export</code> button.
    </ul>
    All armature actions (animations), if any, will get exported along with the
    armature (unless you select <code>Exclude</code> on the exporter screen.
    This is the case even if you don't export a skin (in this case, you can
    still animate the skeleton in jME).
    Use the Blender "Anim" button panel to narrow the start and end frames if
    you wish.
    See the <A href="#tips">Tips section below</A> for important information
    about start and end frames.
    </p><p>
    The exporter handles the various objects in a very modular fashion, and
    there are many good reasons why you might want to export just portions of
    what is described above.
    You can export the skin &amp; bones without the Blender animations
    (say, if you want to use a jME controller, or program your own
    <code>setLocal*()</code> methods.
    You can export just the skeleton, with or without its animations.
    You can export just the skin.
    You can also add non-bone-weighted meshe objects to the Armature object or
    to any specific bones, and you can nest onto these objects.
    Exporting components this way isn't just for learning, testing, or theory--
    the are the basis for some very efficient methods of game animation.
    </p>
    <li>Import into jME
    <p>
        See the bundled sample class code
        <a href="XmlAnimator.java"><code>XmlAnimator.java</code></A>.
        (If your web browser doesn't let you view or download this file,
        get a better browser).
        This sample extends <a href="XmlWorld.java"><code>XmlWorld</code></A>
        to list and execute animations.
    </p>
  </ol>
    <HR/>
    <h4 id="tips">Tips</h4>
    <ul>
      <p>
      <li>If you move bones without an animation controller, like with
      <code>Spatial.setLocal*()</code>, you must run<pre><code>
          skinNode.boneChanged(null);
      </code></pre> on the corresponding
      <code>com.jme.animation.SkinNode</code> in order for the skin to update
      accordingly.
      <p> </p>
      If you use Modeler, the minus key performs this action (I'll add a button
      or menu item to make this more obvious sometime).
      You will need to select the <code>SkinNode</code> before-hand, to tell
      Modeler which skin to update.
      </p>
      <li>To restart an animation (for example to re-run an animation of
      repeat type <i>Clamp</i>), you need to run
      <code>BoneAnimation.reset()</code> before setting the animation active
      (which is how you <i>start</i> an animation), to reset the frame and
      time back to the start of the animation.
    <li>
      Use the Bone Debugger in jME to examine and learn to use your skeletons.
    <li>
      To see what leaf bones are really doing, you will need to add dummy leaf
      bones to your skeleton in Blender.
      This is because jME only loads information about a single location of a
      bone-- the Base/Root.
      Therefore, if a bone has no child, it's impossible to make out anything
      about the bone's rotation (if the bone is rotating, you may make out a
      glimmer as it rotates, but that's about it).
      In Blender, you can use the Outliner to set these dummy bones to be
      invisible.
      You have to turn it off from both Edit and Pose modes in order for it to
      always be invisible.
    <li>
      If you examine the bones on the jME side, you may notice that the
      exporter adds an extra root bone above the Blender bones.
      From the jME perspective, this is the skeleton's <i>root bone</i>.
      To distinguish it from the Blender root bones, we call this automatically
      created bone the <i><b>Super Bone</b></i>.
      This is a work-around for the single-root-bone limitation of
      <code>com.jme.animation</code>.
      It is not unusual to have a single root bone, with no offset, in your
      Blender Armature.
      If that is the case, you won't see the <i>Super Bone</i> in the jME Bone
      Debugger, because the root bone will lay right on top of it.
      In this case, if you apply a translation to the root bone, the
      <i>Super Bone</i> will appear.
    <li>
      Your actions/animations will be accessed from jME through a
      <code>com.jme.animation.AnimationController</code> of the automatically
      created <i>Super Bone</i>.  As described in the previous item, the
      <i>Super Bone</i> node is a child of the node corresponding to your
      Blender Armature, and parent of the Blender root bones.
      This <code>AnimationController</code> can select and control
      <code>com.jme.animation.BoneAnimation</code>s, one for each Blender
      Action (and named from same).
    <li>
      Remember that to use the Blender Weight Painter, you must have the
      Armature in Pose mode before setting the skin mesh to Weight Painter mode.
    <li>
      Very similarly to the previous item, in order to parent a skin mesh
      to a bone (as opposed to the Armature Object or the Armature itself), you
      must put the Armature into pose mode, then parent the skin mesh object to
      the Armature object.
    <li>Make sure when saving key frames which will be used as animation start
      frames, that you choose <code>LocRot</code> and select every bone that
      will be used at all in this animation.
    <li><b>Action Start and End frames.</b>
      Blender animations must end with a key frame if you want the tail segment
      of the animation to show interpolation in Blender.
      Interpolation-retaining exporters like ours only export the key frames.
      Our exporter generates jME-only keyframes for start and/or end frames, if
      the specified frame numbers are not keyframe frames.
      This feature can be exploited to eliminate the duplicate frame joining
      the first frame with the last frame of an animation sequence of repeat
      type <i>Wrap</i>.
      When designing a Blender animation intended for usage with repeat type
      <i>Wrap</i>, set the end frame to one frame before the final keyframe.
      The exporter will generate that keyframe, and in jME the animation will
      smoothly transition from that frame to the first frame of the animation,
      without the momentary pause in animation which you would have otherwise.
    <HR/>
    <DIV class="footer">
      $Revision$
      <BR/>
      Last modified $Date$
      <BR/>
      <span class="addr">blaine (dot) simpson (at) admc (dot) com</span>
    </DIV>
  </BODY>
</HTML>
