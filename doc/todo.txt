$Id$

TODO LIST

Document how to "parent to a bone".

Env. var FAVORJOINS has a bug in some cases.  I am thinking that the problem is
that the the X-Rot axis-flip transform is being moved to the same level as an
explicit transformation, and either one is clobbering the other, or the needed
parenting effect is destroyed.

I don't know whether Blender's Python supports os.environ, which we use for
env. var. FAVORJOINS.  Before 0.4a public is rolled, we need to either change
this to a GUI setting, or ensure the portability.

04a refactor.  Purpose is to improve consistency and generalization so that
material indexing can thereafter be implemented in an intuitive and consistent
way.

    Allow for general, end-user selection of 'join' mode.
    Run through the Object colbit list and add only each Mat to the jME Node or
     Geometry according to well-defined rules.
    Support uv texture Layers.

Add either enforcement or validation for the cases where TriMeshes vs.
QuadMeshes are mandated, like for Morphing and Skins.  Right now, the code
assumes these geometries are TriMeshes.

FIX Spatial uniqueness enforcement.  This is totally screwed up now.
I think the jME recommendation for Spatials to have a unique name in a scene is
 unrealistic and problematic.  Come up with a policy which will accommodate all
 respectable use cases, then enforce that policy vigorously.

Use Python subclassing for the main jme/xml and hottbj/wrapperclasses
classes.  When I first wrote those classes, I didn't know how they needed to
diverge.  Now it is time to eliminate all of the redundant code.

FIX asymmetrical (i.e., xScale != yScale != zScale) scale algorithms.
Scale values are generally not just the values of the matrix diagonals, but
the sqrt of the sums of the squares of row elements.  (Probably needs to be
applied to columns with Blender's screwy matrixes, so check that).

Find out how to retrieve the pose markers for a Blender Action and use those to
write frameNames using that instead of the jme.frameNames game property.
http://blenderartists.org/forum/showthread.php?p=1430654


GUI
    Add Linear Interp toggle forces Linear animation interpolation (work-around
     for broken state of Bezier interpolation in jME's com.jme.animation
     package).
    Add switch whether to export animations of selected armatures.

DOCUMENT
    If user does not want to export Bones, select just the skin mesh instead
     of the Armature.
    If user does not want to export an Armature skin, select just the Armature
     without the skin mesh.

Don't ever write values of negative 0.  Looks terrible, and adds ambiguity,
when rounding results in "-0.000000" or "-0.000" and we write that.

Convert Blender mat "VCol Pain" setting to jME
MaterialState.setColorMaterial(MaterialState.ColorMaterial.AmbientAndDiffuse).
Very likely attr:  colorMaterial="AmbientAndDiffuse".

Consider not writing JmeMaterial referencing elements if the referrent is the
object link of an ancestor Object.  In jME, it is more efficient and powerful
to use scene graph parent/child relationships to inherit colors than to
require explicit links in every material-using node.

Per nymon:  ...give the option of exporting with the modifiers applied, instead of having to save, apply them, export, then reload. The OBJ exporter that comes with Blender does this...

Install archived version of Blender and set the Blender version in
"hottbj_reg.py" to the oldest version that this product works with.

Consider refactoring the huge amount of code in JmeNode.getXmlEl concerned
with accommodating face-specific colors and uv values.  I think this could be
done more simply and efficiently by adding a per-UpdatableMVert .col and by
populating UpdateableMVert.uvco from per-vertex uvs.

Handle unusual Blender objects like lights, cameras, non-face meshes,
non-data meshes, etc.

As soon as I implement proper schema validation in jME core, add the namespace
specs to generated XML.

Provide some means for the designer to specify the BoundingVolume for each mesh.
This satisfies 2 use cases:  1: where one BV type is either required (e.g. the
game may require an OBB to support model movement) or more accurate*;
2: where animations (Blender-designed or jME-controlled) will extend the mesh
beyond a load-time generated BV.
POSTNOTE:  The Blender API has an object boundingBox attribute for Objects.
I don't know how or if the user can modify the box itself though.
* boxes are more accurately bound by BBs, spheres by BSs, angled boxes by OBBs.

Export Vertex Groups so that specific model geometries can be identified and used as bases for effects (such as particles, etc.). 
