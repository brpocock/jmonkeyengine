$Id$

TODO LIST

Use Python subclassing for the main jme/xml and hottbj/wrapperclasses
classes.  When I first wrote those classes, I didn't know how they needed to
diverge.  Now it is time to eliminate all of the redundant code.

FIX non-equal scale algorithms.
Scale values are generally not just the values of the matrix diagonals, but
the sqrt of the sums of the squares of row elements.  (Probably needs to be
applied to columns with Blender's screwy matrixes, so check that).

Check for scaled bones in armatures selected for export.  If any, abort with
message explaining that scaled bones unsupported.  Update docs to explain that
bone scaling is incompatible with jME.


GUI
    Add Linear Interp toggle forces Linear animation interpolation (work-around
     for broken state of Bezier interpolation in jME's com.jme.animation
     package).
    Add switch whether to export animations of selected armatures.

DOCUMENT
    If user does not want to export Bones, select just the skin mesh instead
     of the Armature.
    If user does not want to export an Armature skin, select just the Armature
     without the skin mesh.

Don't ever write values of negative 0.  Looks terrible, and adds ambiguity,
when rounding results in "-0.000000" or "-0.000" and we write that.

Convert Blender mat "VCol Pain" setting to jME
MaterialState.setColorMaterial(MaterialState.ColorMaterial.AmbientAndDiffuse).
Very likely attr:  colorMaterial="AmbientAndDiffuse".

Consider not writing JmeMaterial referencing elements if the referrent is the
object link of an ancestor Object.  In jME, it is more efficient and powerful
to use scene graph parent/child relationships to inherit colors than to
require explicit links in every material-using node.

Per nymon:  ...give the option of exporting with the modifiers applied, instead of having to save, apply them, export, then reload. The OBJ exporter that comes with Blender does this...

Install archived version of Blender and set the Blender version in
"hottbj_reg.py" to the oldest version that this product works with.

Consider refactoring the huge amount of code in JmeNode.getXmlEl concerned
with accommodating face-specific colors and uv values.  I think this could be
done more simply and efficiently by adding a per-UpdatableMVert .col and by
populating UpdateableMVert.uvco from per-vertex uvs.

Handle unusual Blender objects like lights, cameras, non-face meshes,
non-data meshes, etc.

As soon as I implement proper schema validation in jME core, add the namespace
specs to generated XML.

Provide some means for the designer to specify the BoundingVolume for each mesh.
This satisfies 2 use cases:  1: where one BV type is either required (e.g. the
game may require an OBB to support model movement) or more accurate*;
2: where animations (Blender-designed or jME-controlled) will extend the mesh
beyond a load-time generated BV.
POSTNOTE:  The Blender API has an object boundingBox attribute for Objects.
I don't know how or if the user can modify the box itself though.
* boxes are more accurately bound by BBs, spheres by BSs, angled boxes by OBBs.

Export Vertex Groups so that specific model geometries can be identified and used as bases for effects (such as particles, etc.). 
