$Id$

IMPORTANT PYTHON CODING INFO
----------------------------

For Blender Python development in Linux, you really must have a standalone
Python installation.  Blender's distros for Linux do not have the most basic
modules, such as the StringIO (used by the provided Interactive Python Console)
and "os" modules.

Blender-native
--------------

Our final deliverable must work with a vanilla Blender distribution.
Things would be MUCH EASIER FOR US if we would just require users to have a
standalone Python installation present.  Easy for us, but user-unfriendly :(.
Why is this so difficult for us?

    - The Blender-supplied Python interpreter is missing many important
      and basic Python features and modules.

    - Different platform distributions for the same exact Blender version
      have DIFFERENT Python modules available.

    - The Blender startup banner reporting about the Python interpreter is
      often dead wrong.  If they can't even reliably determine whether they
      loaded an external interpreter, IMO they should shut the f*** up
      instead of reporting a false answer.

    - Blender will load an incompatible external Python and look as if it is
      ok, but you may encounter extremely confusing name visibility problems
      as scripts run.  (For example, a name import succeeds, then the script
      throws later on imported when it tries to reference the imported name).

Due to the second point above, we must standardize on something.  So, in order
to satisfy the most end users, we aim to support the following Blender binary:

    Supported Blender binary = 
    The latest production Blender Foundation-supplied binary Blender distro 
     for 32-bit Windows.  If there are multiple variants provided for different
     Python versions, we support the one with the latest offered Python version.

What about users using a different Blender distro?  Well, our product will
just work if (a) the user environment utilizes an external Python
installation, or (b) the Blender distro happens to also include the modules
that we depend on (which modules are in the 32-bit win distro),
To give specific, and sad, examples:  My RPM binary of current Python 2.6
build for 64 bit OpenSUSE does not have modules "os" or "StringIO" (both of
which are included in the Windows builds).

ACCOMMODATING Blender-supplied Python

Now to the development constraints we must live with as a consequence...
** To cause Blender to use its built-in Python interpreter, set env variable
PYTHONHOME to a bogus value (if in UNIX, make sure to export the var). **
N.b.!!!  It is NOT sufficient to unset PYTHONHOME, because that causes Blender
to use its internal discovery method, trying to locate and use an external
Python installation.  N.b.!! DO NOT BELIEVE the Blender startup messages
about what Python interpreter it is using.  Set PYTHONHOME as directed here.
Samples:

    export PYTHONHOME=/dev/null  # Bash shell

    :: In Windows, set an env. var in advanced System settings, or at shell:
    set PYTHONHOME=\dummy

Feature limitations:

    Do not use "except X as y".  [Use "except X, y" instead]

    Do not use string.encode(), string.decode(), or specify an encoding
    type to the unicode() function.  [VERY ANNOYING!]

    Do not use string.format().  Use the old-fashioned % operator instead.

Module limitations:

    Do not use xml package.

    Do not use codecs module.

    Do not use platform module.

--------------------------------------------------------------

If you catch an exception, but the cause could possibly be a code problem,
make sure to report the source code location if you don't re-throw.  For
example, in an exception-catching block:
        ei = exc_info()[2]
        while ei:
            print "  " + ei.tb_frame.f_code.co_filename + ':' \
                + str(tb_lineno(ei))
            ei = ei.tb_next print e
If you catch an exception but don't handle it entirely, you should often
rethrow by just calling "raise".

Bundled files.
If you need to bundle files to be read in by our product at runtime, follow
the example that jmetest/xml.py uses to load the test data *.xml file(s).
The package supplies functions to resolve relative paths to files within the
package, and methods to read the contents of them.


Development Environment
-----------------------

Gotcha:  Be aware that Blender.Load() wipes clean much of the current Python
namespace.  Imports generally have to be repeated after a Load.

The Python code in modules other than "hottbj" are standalone.  That
means you can execute and test them independently of Blender.

With the exception graphical files (which use Blender.Draw or menu
registration, whenever you add a Python source file you should either
(a) add unittest invocations to "alltests.bash"; or (b) add an import of your
new file to "src/blendertest/modules.py".  This way, either directly or
indirectly, modules.py will both syntax check and dependency-check your new
file.

As a consequence of the previous item, "alltests.bash"* can be used as you
develop, to validate your code (except for graphical code).  If you don't
want to keep revalidating "everything" as you code, then use individual
commands to validate (syntax-check + dependency-check + execute), depending
on the script type:

    Standalone modules and test modules: "python -c 'import your.testmodule'"
    ( documented in "testing.txt")
    
    Blender environment: "blenderscript.bash path/to/your/script.bash"

    Graphical scripts:  must be tested interactively.

For myself at least, it's much more convenient to execute my code outside of
Blender.  Most significantly, modules can't be reloaded into Blender's Python
interpreter without restarting Blender.  So, you can edit your module *.py
file all you want, but that will have no effect until you restart Blender.  If
you added 50 syntax errors in a big refactory, you will have dozen of Blender
restarts (each time having to use a menu or type in Python commands to load
your module), just to find out there are additional syntax errors.

You can execute all non-graphical Python scripts from the command-line by
using the blenderscript.bash program.  It executes scripts very quickly.
This applies to both deliverable scripts and unit tests.  Limitations:

    If you need a model for your code to work on, you will need to either save
    your default Blender setup with the target model loaded, or use the
    Blender.Load() function.  Blender.Load() is crashing horribly for me,
    regardless whether blenderscript.bash is involved.  Hopefully it will work
    for you :) .

    The gui.py script definitely requires a graphical screen to run
    (blenderscript.bash draws no Gui in order to make it run very fast).
    I don't know about hottbj_reg.py (not much in it can be tested
    non-interactively).

Even if you prefer to run your scripts from inside Blender, it should still be
of great benefit to use blenderscript.bash to syntax- and dependency-check the
scripts before investing time starting and setting up your Blender interface.

-----------------------

FOOTNOTES

* "alltests.bash" will probably only work "as is" in the following setup:

        32 bit Windows
        Plain Blender 32 bit Windows installed
        MinGW, MSys, or Cygwin
         (to provide a Bash interpreter for the Bash script).
   I have to comment out the 
