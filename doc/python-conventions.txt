$Id$

Python Coding Conventions
-------------------------

Only use modules and features included in the Blender-provided Python engine.
Specifically:

    Do not use "except X as y".  [Use "except X, y" instead]

    Do not use xml.sax

    Do not use string.encode(), string.decode(), or specify an encoding
    type to the unicode() function.  [VERY ANNOYING!]

If you catch an exception, but the cause could possibly be a code problem,
make sure to report the source code location if you don't re-throw.  For
example, in an exception-catching block:
        ei = exc_info()[2]
        while ei:
            print "  " + ei.tb_frame.f_code.co_filename + ':' \
                + str(tb_lineno(ei))
            ei = ei.tb_next print e
If you catch an exception but don't handle it entirely, you should often
rethrow by just calling "raise".

Bundled files.
If you need to bundle files to be read in by our product at runtime, follow
the example that jmetest/xml.py uses to load the test data *.xml file(s).
The package supplies functions to resolve relative paths to files within the
package, and methods to read the contents of them.


Development Environment
-----------------------

The Python code in modules other than blenderjmeexp are standalone.  That
means you can execute and test them independently of Blender.

With the exception graphical files (which use Blender.Draw or menu
registration, whenever you add a Python source file you should either
(a) add unittest invocations to "alltests.bash"; or (b) add an import of your
new file to "src/blendertest/modules.py".  This way, either directly or
indirectly, modules.py will both syntax check and dependency-check your new
file.

As a consequence of the previous item, "alltests.bash" can be used as you
develop, to validate your code (except for graphical code).  If you don't
want to keep revalidating "everything" as you code, then use individual
commands to validate (syntax-check + dependency-check + execute), depending
on the script type:

    Standalone modules and test modules: "python -c 'import your.testmodule'"
    ( documented in "testing.txt")
    
    Blender environment: "blenderscript.bash path/to/your/script.bash"

    Graphical scripts:  must be tested interactively.

For myself at least, it's much more convenient to execute my code outside of
Blender.  Most significantly, modules can't be reloaded into Blender's Python
interpreter without restarting Blender.  So, you can edit your module *.py
file all you want, but that will have no effect until you restart Blender.  If
you added 50 syntax errors in a big refactory, you will have dozen of Blender
restarts (each time having to use a menu or type in Python commands to load
your module), just to find out there are additional syntax errors.

You can execute all non-graphical Python scripts from the command-line by
using the blenderscript.bash program.  It executes scripts very quickly.
This applies to both deliverable scripts and unit tests.  Limitations:

    If you need a model for your code to work on, you will need to either save
    your default Blender setup with the target model loaded, or use the
    Blender.Load() function.  Blender.Load() is crashing horribly for me,
    regardless whether blenderscript.bash is involved.  Hopefully it will work
    for you :) .

    The gui.py script definitely requires a graphical screen to run
    (blenderscript.bash draws no Gui in order to make it run very fast).
    I don't know about blenderjmeexp_reg.py (not much in it can be tested
    non-interactively).

Even if you prefer to run your scripts from inside Blender, it should still be
of great benefit to use blenderscript.bash to syntax- and dependency-check the
scripts before investing time starting and setting up your Blender interface.
